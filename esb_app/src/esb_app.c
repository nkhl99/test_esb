/**
 * @file esb_app.c
 * @author MubeenS
 * @brief Consists of http listener functions that 
 * call the whole operation. And also Kore hooks
 * to start the working threads.
 * @version 0.1
 * @date 2020-09-23
 * 
 * @copyright Copyright (c) 2020
 * 
 */

#include <kore/kore.h>
#include <kore/http.h>
#include <pthread.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/time.h>
#include "esb/esb.h"
#include <time.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <limits.h>
#include <stdio.h>
#include <mysql/mysql.h>

#include "db_access/connector.h"

#define STRING_SIZE 50
#define NUM_THREADS 5

/**
 * A suitable struct for holding the endpoint request handling result.
 */
typedef struct
{
	int status;
	char *bmd_path;
} endpoint_result;

int esb_endpoint(struct http_request *);
int esb_status(struct http_request *);
endpoint_result save_bmd(struct http_request *);

/**
 * HTTP BMD request handler function. (Mapped in esb_app.conf).
 */
int esb_endpoint(struct http_request *req)
{
	printf(">> Received the BMD request.\n");
	endpoint_result epr = save_bmd(req);
	if (epr.status < 0)
	{
		printf("Failed to handle the BMD request.\n");
		return (KORE_RESULT_ERROR);
	}
	else
	{
		/* Invoke the ESB's main processing logic. */
		int esb_status = process_esb_request(epr.bmd_path);
		if (esb_status >= 0)
		{
			printf("\n>> Request successfully inserted.!\n");
			return (KORE_RESULT_OK);
		}
		else
		{
			printf("##ESB failed to process the BMD.##\n");
			clean_dir(epr.bmd_path);
			http_response(req, 400, NULL, 0);
			return (KORE_RESULT_ERROR);
		}
	}
}

/** 
 * HTTP Status info request handler function.(Mapped in esb_app.conf)
 */

int esb_status(struct http_request *req)
{
	char *message_id;
	struct kore_buf *buf;

	http_populate_get(req);

	buf = kore_buf_alloc(128);

	if (http_argument_get_string(req, "MessageID", &message_id))
	{
		char *status;
		status = get_status_info(message_id);
		kore_buf_appendf(buf, "Status : %s\n", status);
		free(status);
	}

	/* Now return the result to the client with a 200 status code. */
	http_response(req, 200, buf->data, buf->offset);
	kore_buf_free(buf);

	return (KORE_RESULT_OK);
}

/*
Creates a directory in the given path and 
returns 0 if successfully created.
*/

static int mkdir_p(const char *path)
{
	const size_t len = strlen(path);
	char _path[PATH_MAX];
	char *p;

	errno = 0;

	/* Copy string so its mutable */
	if (len > sizeof(_path) - 1)
	{
		errno = ENAMETOOLONG;
		return -1;
	}
	strcpy(_path, path);

	/* Iterate the string */
	for (p = _path + 1; *p; p++)
	{
		if (*p == '/')
		{
			/* Temporarily truncate */
			*p = '\0';

			if (mkdir(_path, S_IRWXU) != 0)
			{
				if (errno != EEXIST)
					return -1;
			}

			*p = '/';
		}
	}

	if (mkdir(_path, S_IRWXU) != 0)
	{
		if (errno != EEXIST)
			return -1;
	}

	return 0;
}
/*
A unique path is created by using current date_time as a seed
and appending a random number generated by the rand()
function to the directory name
*/
static char *create_work_dir_for_request(void)
{
	kore_log(LOG_INFO, "Creating the temporary work folder.");
	char *temp_path = malloc(PATH_MAX * sizeof(char));
	time_t now = time(NULL) % 1000;
	srand(now);
	int t = rand() % 100;
	char cwd[100];
	getcwd(cwd, sizeof(cwd));
	sprintf(temp_path, "%s/bmd_files/%ld_%d", cwd, now, t);

	int ret = mkdir_p(temp_path);
	if (ret != 0 && errno == EEXIST)
	{
		char random[50];
		sprintf(random, "_%d", rand() % 100);
		strcat(temp_path, random);
		mkdir_p(temp_path);
	}
	printf("Current Working Directory %s \n ", cwd);

	kore_log(LOG_INFO, "Temporary work folder: %s", temp_path);
	return temp_path;
}

endpoint_result
save_bmd(struct http_request *req)
{
	endpoint_result ep_res;
	/* Default to OK. 1 => OK, -ve => Errors */

	ep_res.status = 1;

	int fd;
	struct http_file *file;
	u_int8_t buf[BUFSIZ];
	ssize_t ret, written;

	/* Only deal with POSTs. */
	if (req->method != HTTP_METHOD_POST)
	{
		kore_log(LOG_ERR, "Rejecting non POST request.");
		http_response(req, 405, NULL, 0);
		ep_res.status = -1;
		return ep_res;
	}

	/* Parse the multipart data that was present. */
	http_populate_multipart_form(req);

	/* Find our file. It is expected to be under parameter named bmd_file */
	if ((file = http_file_lookup(req, "bmd_file")) == NULL)
	{
		http_response(req, 400, NULL, 0);
		ep_res.status = -1;
		return ep_res;
	}

	/* Open dump file where we will write file contents. */
	char bmd_file_path[PATH_MAX];
	char *req_folder = create_work_dir_for_request();
	sprintf(bmd_file_path, "%s/%s", req_folder, file->filename);
	printf("File Path :  %s \n", bmd_file_path);
	fd = open(bmd_file_path, O_CREAT | O_TRUNC | O_WRONLY, 0700);
	if (fd == -1)
	{
		http_response(req, 500, NULL, 0);
		ep_res.status = -1;
		return ep_res;
	}

	for (;;)
	{
		ret = http_file_read(file, buf, sizeof(buf));
		if (ret == -1)
		{
			kore_log(LOG_ERR, "failed to read from file");
			http_response(req, 500, NULL, 0);
			ep_res.status = -1;
			goto cleanup;
		}

		if (ret == 0)
			break;

		written = write(fd, buf, ret);
		kore_log(LOG_INFO, "Written %zd bytes to %s.", written, bmd_file_path);
		if (written == -1)
		{
			kore_log(LOG_ERR, "write(%s): %s",
					 bmd_file_path, errno_s);
			http_response(req, 500, NULL, 0);
			ep_res.status = -1;
			goto cleanup;
		}

		if (written != ret)
		{
			kore_log(LOG_ERR, "partial write on %s",
					 bmd_file_path);
			http_response(req, 500, NULL, 0);
			ep_res.status = -1;
			goto cleanup;
		}
	}

	http_response(req, 200, NULL, 0);
	kore_log(LOG_INFO, ">> file '%s' successfully received",
			 file->filename);
	ep_res.bmd_path = malloc(strlen(bmd_file_path) * sizeof(char) + 1);
	strcpy(ep_res.bmd_path, bmd_file_path);

cleanup:
	if (close(fd) == -1)
		kore_log(LOG_WARNING, "close(%s): %s", bmd_file_path, errno_s);

	if (ep_res.status < 0)
	{
		kore_log(LOG_ERR, "We got an error. Deleteing the file %s", bmd_file_path);
		if (unlink(bmd_file_path) == -1)
		{
			kore_log(LOG_WARNING, "unlink(%s): %s",
					 bmd_file_path, errno_s);
		}
	}
	else
	{
		ep_res.status = 1;
		printf("BMD is saved\n");
	}
	return ep_res;
}

pthread_t thread_id[NUM_THREADS];
void kore_parent_configure(int argc, char *argv[])
{
	int error;
	printf("\n%%%%%%%%%% kore_parent_configure %%%%%%%%%%\n");
	if (mysql_library_init(0, NULL, NULL))
	{
		fprintf(stderr, "Could not initialize MySQL client library\n");
		return;
	}
	int t = connect_to_db();
	if (t == 1)
		printf("Connected to db.\n");
	for (int i = 0; i < NUM_THREADS; i++)
	{
		error = pthread_create(&(thread_id[i]), NULL,
							   poll_database_for_new_requests, NULL);
		if (error != 0)
			printf("\nThread can't be created :[%s]",
				   strerror(error));
	}
}

/*Function to cancel threads*/
void kore_parent_teardown(void)
{
	printf("<<<<< kore_parent_teardown >>>>\n");
	for (int i = 0; i < NUM_THREADS; i++)
	{
		pthread_cancel(thread_id[i]);
	}
}
